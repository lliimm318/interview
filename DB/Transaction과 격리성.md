# Transaction

A, B, C 테이블에 차례로 insert 할 때 A, B에만 insert하고 C에 에러가 나서 insert를 못한다고 가정해보자.

그러면 결과적으로 데이터는 믿을 수 없어진다. 이를 해결하기 위해 **All Or Noting** 전략을 사용한다.

A, B, C 모두에게 insert하거나 모두에게 insert 하지 않는 것이다.

이 방법을 사용하기 위해 트랜잭션이라는 단위를 사용 하는데, 트랜잭션은 최소 단위이며 트랜잭션이 적용된 부분에서 오류가 났다면 A, B를 롤백 해준다.

## 트랜잭션 특징

1. **원자성(Atomicity)**
트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.

2. **일관성(Consistency)**
일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 한다. 즉, 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.

3. **영속성(Durability)**
트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.

4. **격리성(Isolation)**
실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.

## 격리성 문제
격리성은 실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다는 것이다. 이에 따른 문제는 3가지가 있다.

### Dirty Read
다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말한다.

![image](https://github.com/lliimm318/interview/assets/66578746/24c2a4b1-8aaf-4d97-80a5-906dd0e8c194)

이런 경우 Transaction_1이 정상처리되지 않고 롤백 되면, 그 값을 이미 읽은 Transaction_2는 잘못된 값을 가지고 본인의 로직을 처ㅣ리하게 된다.

### Non-Repeatable Read
한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상

![image](https://github.com/lliimm318/interview/assets/66578746/179fe524-37ad-49ce-bf24-1733b67165be)

### Phantom Read
한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상

![image](https://github.com/lliimm318/interview/assets/66578746/e7577558-83fb-4ae7-a465-6ded82acba4f)


*여기서 Phantom Read와 Non-Repeatuable Read를 햇갈릴 수 있다.*

**Non-Repeatable Read는 1개**의 Row의 데이터의 값이 변경되는 것이며 **Phanton Read는 다건**을 요청하는 것에 대해서 데이터의 값이 변경되는 것!

# 격리성 수준
격리수준은 ANSI/ISO SQL 표준(SQL92)에서 정의한 내용

참고) https://jaeyeong951.medium.com/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-85e490f02229

## Read Uncommitted
트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용. 

해당 수준에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 일어날 수 있다. 이 설정은 정합성에 문제가 있기 때문에 권장하는 설정은 아님

## Read Committed
트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용. 가장 기본적인 수준의 격리이다.

1. 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다.

2. 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.

따라서 Dirty Read / Drity Write(아직 커밋되지 않은 값을 덮어씀)의 발생가능성을 막는다! 

**커밋 되지 않은 데이터에 대해서는 실제 DB 데이터가 아닌 Undo 로그에 있는 이전 데이터를 가져온다.** 

하지만 Non-Repeatable Read와 Phanton Read에 대해서는 발생 가능성이 있다..

### 구현
보통 먼저 쓴 트랜잭션이 커밋되거나 중단될 때까지 나머지 쓰기 트랜잭션을 지연시키는 방법을 사용한다.

구현하는 가장 간단한 **방법은 모든 읽기에 동일한 락**을 거는거다! 

그러면 객체에 아직 커밋되지 않은 변경이 있을 때 읽기가 실행되지 않도록 보장할 수 있다. 

하지만 이 방법은 **너무 비효율적이다... 때문에 Read Committed 격리 수준에서는 잘 사용되지 않음**

그래서 대부분의 데이터베이스는 현재 쓰기를 하고 있는 트랜잭션에서 쓴 값과 과거에 가장 최근 커밋된 값을 모두 기억하고 
지금 쓰기를 진행중인 트랜잭션을 제외한 나머지 트랜잭션은 과거의 값을 읽게하는 방법을 사용한다 ~

## Repeatable Read
트랜잭션내에서 삭제, 변경에 대해서 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 백업데이터를 읽게 한다. 

이렇게 함으로써 트랜잭션 중 값의 변경에 대해서 일정한 값으로 처리할 수 있습니다. 

이렇게하면 삭제와 수정에 대해서 트랜잭션내에서 불일치를 가져오던 Non-Reapeatable Read를 해소할 수 있다.!

### 구현

![image](https://github.com/lliimm318/interview/assets/66578746/efb727a3-c9e3-4803-8f0e-b849e310e9e6)

보통 스냅숏 격리 방식으로 구현한다. 
각 트랜잭션은 데이터베이스의 일관된 스냅숏으로 부터 읽어서 다른 트랜잭션이 아무리 실제 데이터를 바꾸더라도 각 트랜잭션은 특정 과거 시점의 데이터를 바라 본다.

Read Committed 에서 사용한 메커니즘을 조금 더 심화한 방법을 사용한다. 

진행 중인 수많은 트랜잭션의 서로 다른 시점의 데이터베이스 상태를 봐야해서 데이터베이스는 객체마다 커밋된 버전 여러개를 유지한다. 

이처럼 데이터베이스가 객체의 여러 버전을 함께 유지하는 기법은 MVCC(Multi-Version Concurrency Control, 다중 버번 동시성 제어)라고 부른다.

Read Committed 격리만 제공한다면 객체마다 버전 두개씩만 유지하면 충분하다는거다. (가장 최근에 커밋된 버전과 쓰기가 이루어졌지만 아직 커밋되지 않은 버전)

MVCC 기반 스냅숏 격리는 트랜잭션마다 계속 증가하는 고유한 트랜잭션 ID(txid)를 부여하는 방식으로 구현한다. 
현재 트랜잭션의 txid 보다 낮은 txid 가 쓴 값만 읽게하는 방식!

## Lost Update : 갱신 손실
Repeatable Read 또한 막지 못하는 경쟁 조건이 여러가지 있다. **그 중 하나가 갱신 손실(lost update)!**

갱신 손실이란 말그대로 갱신이 손실되는 것을 말하는데, 경쟁 조건에서 한쪽의 갱신이 다른 한쪽의 갱신을 덮어씌워버리는 것.

이와 관련한 가장 간단한 예시로 아래와 같은 카운터 증가 연산이 있다.

![image](https://github.com/lliimm318/interview/assets/66578746/fd7f55ca-53c2-4125-a9dd-d3f6a560a77c)

User 1 의 증가연산은 User 2 의 증가연산에 의해 손실(lost)되었다. 
MVCC 기반의 Repeatable Read 격리 수준은 이 현상을 방지할 수 없다.

### 해결법

**원자적 쓰기 연산**

대부분의 데이터베이스는 다음처럼 read-modify-write 주기를 구현한 원자적 쓰기를 제공한다.

```
UPDATE conters SETR value = value + 1 WHERE key = 'foo';
```

모든 쓰기가 위처럼 쉽게 원자적 연산으로 표현되는 않겠지만 이를 사용할 수 있는 상황에서는 보통 이것이 최선의 선택이다.

**명시적 잠금**

또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것. 

한 트랜잭션에서 read-modify-write 주기에 들어가면 다른 트랜잭션은 그 주기가 끝날 때 까지 해당 객체를 읽을 수 없게 한다.

**갱신 손실 자동 감지**

위처럼 하지않고 병렬 실행을 허용하되, 트랜잭션 관리자가 갱신 손실을 발견하면 해당 트랜잭션을 종료시키고 read-modify-write 주기를 재시도하는 방법. 

실제로 Postgresql의 Repeatable Read, 오라클의 Serializable 격리 수준은 갱신 손실이 발생하면 이를 감지하고 트랜잭션을 종료시킨다. 

하지만 MySQL/InnoDB 의 Repeatable Read 격리 수준은 이를 감지하는 기능을 제공하지 않는다.ㅠㅠ 😭

## Serializable Read
여러 트랜잭션이 병렬로 실행되었다한들 최종 결과는 각 트랜잭션이 직렬로 차례차례 수행되었을 때와 같음을 보장한다.

트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않도록 하는 설정이다.

보통 가장 강력한 격리 수준으로 여겨지며 데이터베이스에서 발생할 수 있는 모든 경쟁조건을 막아준다.

직렬성 격리만 사용하면 모든 문제를 해결해주겠지만 그만큼의 희생이 따르기에 약한 격리 수준을 사용하고 동시성에 취약적인 부분만 애플리케이션이 명시적인 잠금으로 해결해주는 방법을 사용

### 구현

- 말 그대로 트랜잭션을 들어온 순서대로 실행하기 (유리한 경우도 있겠으나 다소 비효율적

- 2단계 잠금(2PL)
  
- 비관적/낙관적 동시성 제어 기법(SSI: 직렬성 스냅숏 격리)

<br/>
<br>

# 정리
트랜잭션은 우리가 개발할 애플리케이션이 수많은 소프트웨어/하드웨어 문제를 다소 단순하고 쉽게 해결할 수 있는 방법을 제시한다.

다양한 종류의 오류에 대한 대처가 단 하나의 트랜잭션 롤백으로 해결된다. 애플리케이션은 그저 재시도만!

많은 데이터베이스들이 트랜잭션과 여러가지 격리수준을 제공해준다고 말하지만, 
**동일한 격리 수준을 제공하는 두 가지 데이터베이스라도 한쪽에서 일어나지않던 문제가 다른쪽에서 일어날 수 있다!!!**

