# 잠금(Locking) 기법

locking은 하나의 트랝잭션이 실핼하는 동안 특정 데이터 항목에 대해 다른 트랜잭션이 접근하지 못하게 **상호배제** 기능을 제공하는 것!<br>
트랜잭션 하나가 락을 설정하면 걔가 잠금을 해제하기 전까지 데이터를 독점으로 사용할 수 있다.

*lock(잠금) / unlock(해제)*

## 잠금 설정
모두 해제할 땐 unlock 연산을 한답니당 ~

### 공유 잠금 (Shared lock: S-lock)
- 읽기(read) 연산만 가능하다
  - T1에서 x 에게 s-lock을 설정한 경우 T1은 read(x)만 가능
- 하나의 데이터 항목에 대해 공유 잠금이 가능하다.
  - 동시에 다른 트랜잭션에도 s-lock 설정 가능
- 다른 트랜잭션도 읽기 연산만 수행 가능하다

### 배타 잠금(Exclusive lock: X-lock)
- 읽기, 쓰기 연산 모두 가능
- 하나의 데이터 대해 하나의 베타 잠금만 가능
  - 동시에 여러 개 배타잠금 불가
- 하나의 트랜잭션이 베타잠금이 되어있다면, 다른 트랜잭션은 읽기와 쓰기 모두 불가

### 잠금 설정 규칙
- 읽기 연산 실행 전에 S-lock(x)이나 X-lock(x)를 실행해야 함
- 쓰기 연산을 실행하려면 베타 잠금 실행
- 연산이 종료되면 언락 해줘야 함 (S-lock(x)이나 X-lock(x) 연산 실행 후에만 unlock(x) 연산 실행 가능)

### 잠금 단위 
![image](https://github.com/lliimm318/interview/assets/66578746/2cd3f55f-0638-4cc2-8e4c-54edc0ad5d7c)

잠금 단위가 클수록 동시성(병행성) 수준은 낮아지고, 동시성 제어 기법은 간단해진다

잠금 단위가 작아질 수록 동시성 수준은 높아지고, 관리는 복잡해 짐

### 잠금 한계
- 교착상태
- 단순 잠금은 직렬 스케줄을 보장 못함 (2단계 잠금 규약 사용)

#### 2단계 잠금 규약 (2PL)
- **확장단계** : lock 연산만 수행 가능 (unlock 연산 x)
- **축소단계** : unlock 연산만 수행 가능 (lock 연산 x)

데이터 오류 가능성을 사전 예방 가능하고, 알고리즘이 간단해서 직렬 가능한 스케줄을 보장 가능하다. 하지만 아래 그림의 오른쪽 경우처럼 2PL로도 교착상태가 해결되진 않는다.

![image](https://github.com/lliimm318/interview/assets/66578746/9a946fa1-70ec-4219-aee6-fb96856661cd)

이는 업격한 2PL로 해결가능하다!

![image](https://github.com/lliimm318/interview/assets/66578746/df78f166-3a71-4dc6-9480-b5485f1996a6)

모든 X-lock에 대한 unlock 연산을 트랜잭션이 완전히 완료된 후에 실행하는 것

이렇게 하면 완료되지 않은 트랜잭션에 의해 갱신된 데이터를 다른 트랜잭션이 읽거나 쓸 가능성을 원천적으로 봉쇄할 수 있어 연쇄 복귀 문제를 해결할 수 있다.
현재 대부분의 DBMS에서 엄격한 2PL 규약을 이용하여 동시성 제어를 구현한다. 
